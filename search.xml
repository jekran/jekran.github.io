<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java 基础]]></title>
    <url>%2F2019%2F11%2F23%2FJava-%E5%9F%BA%E7%A1%80.html</url>
    <content type="text"><![CDATA[面向对象和面向过程的区别 面向过程 ： 面向过程比面向对象性能高。Java是半编译语言（先编译成.class字节码文件，然后由虚拟机解释执行，Oracle JDK 提供的JVM都提供了JIT（Just-In-Time）编译器，及时编译，提高热点代码的执行效率，在运行时，JVM会把这些代码编译成与本地平台相关的机器码，并进行各种层次的优化 -Xint告诉JVM只进行解释执行，不对代码进行编译；-Xcomp则是告诉JVM不要进行解释执行，这种模式也叫做“最大优化级别”，但实际上也并不一定会高效。），最终的执行代码并不是可以直接被CPU执行的二进制机械码。类调用时需要实例化，开销比较大，比较消耗资源，而面向过程语言大多都是直接编译成机械码在电脑上执行，并且其它一些面向过程的脚本语言性能也并不一定比Java好。所以当性能是最重要的考量因素的时候，比如单片机、嵌入式开发、Linux/Unix等一般采用面向过程开发。 面向对象 ：面向对象易复用，易扩展，易维护。因为面向对象有封装、继承、多态性的特性，所以可以设计出低耦合的系统，使系统更加灵活、更加易于维护。 JVM是运行Java字节码的虚拟机，针对不同操作系统有不同实现，目的是使用相同的字节码能给出相同的结果，字节码和不同系统的JVM实现，是“一次编译，处处运行的关键。” JDK包含jre，编译器（javac)和工具（javadoc和jdb） JREJRE 是 Java运行时环境,包括虚拟机，java类库，java命令和其他一些基础构件，但是，它不能用于创建新程序 OpenJDK OracleJDK区别 OpenJDK 是一个参考模型并且是完全开源的，而Oracle JDK是OpenJDK的一个实现，并不是完全开源的； Oracle JDK 比 OpenJDK 更稳定。 字符型常量和字符串常量的区别? 字符常量相当于一个整型值( ASCII 值),可以参加表达式运算; 字符串常量代表一个地址值(该字符串在内存中存放位置) char在Java中占两个字节 重载重写区别？ 重载： 发生一个类当中， 方法名必须相同，参数类型，个数，顺序不同，返回值和访问修饰符可以不同，发生在编译时 重写：发生在父子类中，方法名、参数列表必须相同，返回值范围小于等于父类，异常范围小于等于父类，访问修饰符大于等于父类。 Java 面向对象编程三大特性: 封装 继承 多态封装 对象属性私有化，提供外界访问方法 继承 复用父类属性，子类拥有父类所有属性和方法（包括私有），但无法访问私有属性和方法，只是拥有。 多态 程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定（继承和实现） String StringBuffer 和 StringBuilder 的区别是什么? String 为什么是不可变的?可变性 使用final修饰字符数组，StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。 性能 String会生成新对象，StringBuffer/Stringbuilder操作本身 接口和抽象类的区别是什么？ 接口的方法默认是 public，所有方法在接口中不能有实现(Java 8 开始接口方法可以有默认实现），而抽象类可以有非抽象的方法。 接口中除了static、final变量，不能有其他变量，而抽象类中则不一定。 一个类可以实现多个接口，但只能实现一个抽象类。接口自己本身可以通过extends关键字扩展多个接口。 接口方法默认修饰符是public，抽象方法可以有public、protected和default这些修饰符（抽象方法就是为了被重写所以不能使用private关键字修饰！）。 从设计层面来说，抽象是对类的抽象，是一种模板设计，而接口是对行为的抽象，是一种行为的规范。 成员变量与局部变量的区别有哪些？ 成员变量如果没有被赋初值:则会自动以类型的默认值而赋值（一种情况例外:被 final 修饰的成员变量也必须显式地赋值），而局部变量则不会自动赋值。 从变量在内存中的存储方式来看:如果成员变量是使用static修饰的，那么这个成员变量是属于类的，如果没有使用static修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量则存在于栈内存。 == 与 equals(重要) == 判断两个对象地址是否相等，即是否为同一个对象（基本类型比较值，引用类型比较地址值） equals 没有覆盖equals方法，等价于== 覆盖，比较内容，内容相等则返回true object 的 equals 方法是比较的对象的内存地址,String 的 equals 方法比较的是对象的值。 当创建 String 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 String 对象。 hashCode 与 equals (重要)hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个int整数, 确定对象在哈希表中的索引位置，定义在Oject类中 为什么要有 hashCode、 举例，把对象加入 HashSet 时,会首先计算hashcode判断位置，如果相同则调用equals方法检查对象是否相同，如果相同则不加入，不同则重新计算散列值hashCode() 的默认行为是对堆上的对象产生独特值。如果没有重写 hashCode()，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据），两个对象相等则hashcode一定相等，hashcode相等，对象不一定相等 Java中只有值传递 方法不能修改一个基本数据类型的参数 方法可以改变对象参数的状态 方法不能让对象参数引用别的对象 线程，进程，进程 线程：轻量级进程，一个进程可产生多个线程，同类的多个线程共享同一块内存空间和一组系统资源，切换负担比进程小 程序：含有指令和数据的文件，存储在磁盘或者其他存储设备中，静态的代码 进程：属于操作系统范畴，程序在执行时，将会被操作系统载入内存，程和进程最大的不同在于基本上各进程是独立的，各线程则不一定 线程有哪些基本状态? 线程在运行中只可能处于以下6种状态中的一种 状态变迁创建处于NEW（新建）状态，调用start方法处于READY（可运行）状态，获得cpu时间片处于RUNNING(运行)状态，操作系统隐藏了这两种，统称RUNNABLE(运行中) final 修饰变量，基本类型值不可被修改，引用类型引用对象不可修改 修饰类，类不可被继承，所有成员方法隐式指定为final 类中所有private方法被隐式修饰为final static 修饰成员变量和成员方法：静态变量存储于方法区，被类中所有对象共享 静态代码块： 静态代码块—&gt;非静态代码块—&gt;构造方法，不管创建多少对象，只执行一次（类加载器中有缓冲区，虚拟机运行一次类只会被加载一次） 静态内部类（static修饰类的话只能修饰内部类）：非静态内部内在编译完成后会隐含的保存一个指向外部内的引用，而静态创建不需要依赖任何外部类，不可使使用外部类非静态变量和成员方法 静态导包(import static 用来导入类中的静态资源，1.5之后的新特性)：可直接使用类中静态属性，方法 this引用类的当前实例。 super 用于从子类访问父类的属性和方法。 在构造器中调用父类构造方法，必须放在第一行，this调用本类其他构造方法，也得放在第一行，否则编译报错。 this，super不能用于static方法中，this和super是属于对象范畴的东西，而静态方法是属于类范畴的东西。 异常处理java.lang.Throwable Error（错误）：不可查的，程序无法处理的错误， 如Java虚拟机运行错误（Virtual MachineError），类定义错误（NoClassDefFoundError）等。 Exception：:是程序本身可以处理的异常 Throwable类常用方法 public string getMessage():返回异常发生时的简要描述 public void printStackTrace():在控制台上打印Throwable对象封装的异常信息 异常处理 try：捕获异常，可接零个或多个catch块，零个则必须跟finally块 catch：处理捕获到的异常 finally：是否捕获都会被执行，try或catch中遇到return，finally将在方法返回之前执行，并且final块语句返回值会覆盖前面的返回值。 特殊情况不会被执行 final语句块第一行产生异常 在前面调用System.exit(int)方法 程序所在线程死亡 关闭cpu 阻止序列化transient：阻止修饰的变量序列化和被反序列化，不能修饰方法和类 获取键盘输入两种办法Scanner： Scanner input = new Scanner(System.in); String s = input.nextLine(); input.close(); BufferedReader： BufferedReader input = new BufferedReader(new InputStreamReader(System.in)); String s = input.readLine(); Java 中 IO 流类型 按流向，分为输入和输出流 按操作单元，分为字符流和字节流 按角色，分为节点流和处理流 总共40多个类，都是从如下4个抽象基类派生出来 InputStream/Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。 OutputStream/Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。 按操作方式分类解构图： 按操作对象分类结构图： 既然有了字节流,为什么还要有字符流? 字符流是由虚拟机将字节转换得到，过程非常耗时，容易乱码，直接提供字符流，操作字符，图片，音频等媒体文件用字节流 BIO,NIO,AIO 有什么区别? BIO (Blocking I/O)： 同步阻塞I/O模式，数据的读取写入必须阻塞在一个线程内等待其完成 NIO (New I/O)： NIO是一种同步非阻塞的I/O模型，基于通道的I/O操作方法，提供了与传统BIO模型中的 Socket 和 ServerSocket 相对应的 SocketChannel 和 ServerSocketChannel 两种不同的套接字通道实现，低负载、低并发的应用程序，可以使用同步阻塞I/O来提升开发速率和更好的维护性；对于高负载、高并发的（网络）应用，应使用 NIO 的非阻塞模式来开发 AIO (Asynchronous I/O): AIO 也就是 NIO 2：异步非阻塞的IO模型。异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。 Collections 工具类和 Arrays 工具类常见方法 Collections 排序操作 void reverse(List list)//反转 void shuffle(List list)//随机排序 void sort(List list)//按自然排序的升序排序 void sort(List list, Comparator c)//定制排序，由Comparator控制排序逻辑 void swap(List list, int i , int j)//交换两个索引位置的元素 void rotate(List list, int distance)//旋转。当distance为正数时，将list后distance个元素整体移到前面。当distance为负数时，将 list的前distance个元素整体移到后面。 查找,替换操作 int binarySearch(List list, Object key)//对List进行二分查找，返回索引，注意List必须是有序的 int max(Collection coll)//根据元素的自然顺序，返回最大的元素。 类比int min(Collection coll) int max(Collection coll, Comparator c)//根据定制排序，返回最大元素，排序规则由Comparatator类控制。类比int min(Collection coll, Comparator c) void fill(List list, Object obj)//用指定的元素代替指定list中的所有元素。 int frequency(Collection c, Object o)//统计元素出现次数 int indexOfSubList(List list, List target)//统计target在list中第一次出现的索引，找不到则返回-1，类比int lastIndexOfSubList(List source, list target). boolean replaceAll(List list, Object oldVal, Object newVal), 用新元素替换旧元素 同步控制 提供了多个synchronizedXxx()方法，效率非常低，需要线程安全的集合类型时考虑使用 JUC 包下的并发集合。 设置不可变集合 emptyXxx(): 返回一个空的、不可变的集合对象，此处的集合既可以是List，也可以是Set，还可以是Map。 singletonXxx(): 返回一个只包含指定对象（只有一个或一个元素）的不可变的集合对象，此处的集合可以是：List，Set，Map。 unmodifiableXxx(): 返回指定集合对象的不可变视图，此处的集合可以是：List，Set，Map。 上面三类方法的参数是原有的集合对象，返回值是该集合的”只读“版本。 Arrays类的常见操作 排序 : sort() 查找 : binarySearch() 比较: equals() 填充 : fill() 转列表: asList() 需传入对象数组 正确的将数组转换为ArrayList? List list = new ArrayList&lt;&gt;(Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)) &lt;-------- Integer [] myArray = { 1, 2, 3 }; List myList = Arrays.stream(myArray).collect(Collectors.toList()); //基本类型也可以实现转换（依赖boxed的装箱操作） int [] myArray2 = { 1, 2, 3 }; List myList = Arrays.stream(myArray2).boxed().collect(Collectors.toList()); &lt;-------- List&lt;String&gt; il = ImmutableList.of(&quot;string&quot;, &quot;elements&quot;); // from varargs List&lt;String&gt; il = ImmutableList.copyOf(aStringArray); // from array &lt;-------- List&lt;String&gt; l1 = Lists.newArrayList(anotherListOrCollection); // from collection List&lt;String&gt; l2 = Lists.newArrayList(aStringArray); // from array List&lt;String&gt; l3 = Lists.newArrayList(&quot;or&quot;, &quot;string&quot;, &quot;elements&quot;); // from varargs &lt;-------- List&lt;String&gt; list = new ArrayList&lt;String&gt;(); CollectionUtils.addAll(list, str); 转字符串 : toString() 复制: copyOf() 疑难点 正确使用 equals 方法：推荐使用 java.util.Objects#equals(JDK7 引入的工具类)。 public static boolean equals(Object a, Object b) { // 可以避免空指针异常。如果a==null的话此时a.equals(b)就不会得到执行，避免出现空指针异常。 return (a == b) || (a != null &amp;&amp; a.equals(b)); } 所有整型包装类对象值的比较必须使用equals方法。 使用自动装箱方式创建一个Integer对象时，当数值在-128 ~127时，会将创建的 Integer 对象缓存起来，当下次再出现该数值时，直接从缓存中取出对应的Integer对象 浮点数之间的等值判断，基本数据类型不能用==来比较，包装数据类型不能用 equals 来判断。 BigDecimal Bigdecimal 主要用于操作大浮点数， BigInteger用于操作大整数（超过long类型） Collection.toArray()使用 String [] s= new String[]{ &quot;dog&quot;, &quot;lazy&quot;, &quot;a&quot;, &quot;over&quot;, &quot;jumps&quot;, &quot;fox&quot;, &quot;brown&quot;, &quot;quick&quot;, &quot;A&quot; }; List&lt;String&gt; list = Arrays.asList(s); Collections.reverse(list); s=list.toArray(new String[0]);//没有指定类型的话会报错 由于JVM优化，new String[0]作为Collection.toArray()方法的参数现在使用更好，new String[0]就是起一个模板的作用，指定了返回数组的类型，0是为了节省空间，因为它只是为了说明返回的类型。 不要在 foreach 循环里进行元素的 remove/add 操作 java.util包下面的所有的集合类都是fail-fast的，而java.util.concurrent包下面的所有的类都是fail-safe的。 每次迭代都会调用hasnext方法（当前游标是否等于集合容量），如果返回true，则调用next方法，首先调用checkForComodification方法检查（ modCount表示这个迭代器期望该集合被修改的次数，expectedModCount表示这个迭代器期望该集合被修改的次数，判断不等则抛异常）。 程序设计实现最小值函数 自己设计一个泛型的获取数组最小值的函数.并且这个方法只能接受Number的子类并且实现了Comparable接口。 public static &lt;T extends Number &amp; Comparable&lt;? super T&gt;&gt; T min(T[] arr) { if(arr == null || arr.length == 0) { return null; } T min = arr[0]; for (T t : arr) { if(min.compareTo(t) &gt; 0) { min = t; } } return min; } int minInteger = min(new Integer[]{1, 2, 3});//result:1 double minDouble = min(new Double[]{1.2, 2.2, -1d});//result:-1d String typeError = min(new String[]{&quot;1&quot;,&quot;3&quot;});//报错 使用数组实现栈public class MyStack { private int[] storage; private int capacity; private int count; private static final int GROW_FACTORY = 2; public MyStack() { this.capacity = 16; this.storage = new int[capacity]; } public MyStack(int initialCapacity) { if(initialCapacity &lt; 1) { throw new IllegalArgumentException(&quot;capacity too small&quot;); } this.capacity = initialCapacity; this.storage = new int[capacity]; } public void push(int value) { if(count == capacity) { ensureCapacity(); } storage[count ++] = value; } private void ensureCapacity() { int newSize = capacity * GROW_FACTORY; storage = Arrays.copyOf(storage, newSize); capacity = newSize; } /** * 返回栈顶元素并出栈 * @return */ public int pop() { count --; if(count == -1) { throw new IllegalArgumentException(&quot;capacity is empty&quot;); } return storage[count]; } /** * 返回栈顶元素不出栈 * @return */ public int peek() { if(count == 0) { throw new IllegalArgumentException(&quot;capacity is empty&quot;); } return storage[count - 1]; } public boolean isEmpty() { return count == 0; } public int size() { return count; } Servlet总结 主要负责接收用户请求 定义方法void init(ServletConfig config) throws ServletException void service(ServletRequest req, ServletResponse resp) throws ServletException, java.io.IOException void destroy() java.lang.String getServletInfo() ServletConfig getServletConfig() 生命周期 web容器加载servlet并将其实例化后，servlet生命周期开始，容器运行init方法进行初始化，请求到达时调用service方法，会根据需要调用请求对应的doGet()或doPost()等方法，当服务器关闭或者应用被卸载时服务器会将servlet实例销毁，此时会调用destroy方法，init和destroy方法只会执行一次，service方法每次请求都会执行。 Form标签里的method的属性为get时调用doGet()，为post时调用doPost()。 get和post请求的区别 get请求是用来从服务器上获得资源，post请求时用来向服务器提交数据 浏览器get post请求 get 地址栏有长度限制，谷歌2M，幂等，浏览器缓存 post 放在请求头或者请求实体里，无限制, 不幂等，无法设为书签 post相对安全，需要加密或者用https。 接口中的get和post get长度限制，服务器会处理整个url，太长影响性能,可以将数据放入body中 post 无限制，可将数据放入url中 get 请求一次？ post请求两次？ 客户端优化实现细节， 跟post和get本身没有关系 Servlet不是线程安全的，多线程并发的读写会导致数据不同步的问题,只读属性最好定义为final类型的 转发(Forward)和重定向(Redirect)的区别转发是服务器行为，重定向是客户端行为 转发request.getRequestDispatcher(&quot;login_success.jsp&quot;).forward(request, response); 重定向 通过服务器返回的状态码实现，通过HttpServletResponse的setStatus(int status)方法返回301，302，浏览器会到新的网址重新请求资源 转发由服务器请求新接口返回数据，浏览器地址不变，重定向显示新url 转发可以共享数据，重定向不可 一般转发用于根据角色转发到相应模块，重定向用于登出返回主页 重定向效率较高 JSP和Servlet是什么关系 - jsp 本质就是servlet servlet先编译后部署，jsp先部署后编译（会在第一次访问时编译成class文件，之后由该class文件直接处理） servlet侧重于逻辑，jsp侧重于视图，第一次请求后会快很多 JSP有哪些内置对象、作用分别是什么 JSP有9个内置对象 request：封装客户端的请求，其中包含来自GET或POST请求的参数； response：封装服务器对客户端的响应； pageContext：通过该对象可以获取其他对象； session：封装用户会话的对象； application：封装服务器运行环境的对象； out：输出服务器响应的输出流对象； config：Web应用的配置对象； page：JSP页面本身（相当于Java程序中的this）； exception：封装页面抛出异常的对象。 Request对象的主要方法有哪些 setAttribute(String name,Object)：设置名字为name的request 的参数值 getAttribute(String name)：返回由name指定的属性值 getAttributeNames()：返回request 对象所有属性的名字集合，结果是一个枚举的实例 getCookies()：返回客户端的所有 Cookie 对象，结果是一个Cookie 数组 getCharacterEncoding() ：返回请求中的字符编码方式 = getContentLength() ：返回请求的 Body的长度 getHeader(String name) ：获得HTTP协议定义的文件头信息 getHeaders(String name) ：返回指定名字的request Header 的所有值，结果是一个枚举的实例 getHeaderNames() ：返回所以request Header 的名字，结果是一个枚举的实例 getInputStream() ：返回请求的输入流，用于获得请求中的数据 getMethod() ：获得客户端向服务器端传送数据的方法 getParameter(String name) ：获得客户端传送给服务器端的有 name指定的参数值 getParameterNames() ：获得客户端传送给服务器端的所有参数的名字，结果是一个枚举的实例 getParameterValues(String name)：获得有name指定的参数的所有值 getProtocol()：获取客户端向服务器端传送数据所依据的协议名称 getQueryString() ：获得查询字符串 getRequestURI() ：获取发出请求字符串的客户端地址 getRemoteAddr()：获取客户端的 IP 地址 getRemoteHost() ：获取客户端的名字 getSession([Boolean create]) ：返回和请求相关 Session getServerName() ：获取服务器的名字 getServletPath()：获取客户端所请求的脚本文件的路径 getServerPort()：获取服务器的端口号 removeAttribute(String name)：删除请求中的一个属性 request.getAttribute()和 request.getParameter()有何区别 getParameter是获取POST/GET传递的参数值， 返回的string，只能传字符串 getAttribute 是获取容器中的值，返回的object，可以传对象 自动刷新(Refresh) 可以实现一段时间之后自动跳转到另一个页面，还可以实现一段时间之后自动刷新本页面 Response.setHeader(&quot;Refresh&quot;,&quot;5;URL=http://localhost:8080/servlet/example.htm&quot;); 实现会话跟踪的技术有哪些 使用cookie: 向客户端发送cookieCookie c =new Cookie(&quot;name&quot;,&quot;value&quot;); //创建Cookie c.setMaxAge(60*60*24); //设置最大时效，此处设置的最大时效为一天 response.addCookie(c); //把Cookie放入到HTTP响应中 从客户端读取Cookie String name =&quot;name&quot;; Cookie[]cookies =request.getCookies(); if(cookies !=null){ for(int i= 0;i&lt;cookies.length;i++){ Cookie cookie =cookies[i]; if(name.equals(cookis.getName())) //something is here. //you can get the value cookie.getValue(); } } 可以持久保存，不需要服务器资源 不安全，有大小限制，浏览器可禁用cookie url重写：（必须对网站的URL进行编码，页面需动态生成） 隐藏的表单域：（所有页面必须是表单提交之后的结果。） HttpSession： 当一个用户第一次访问某个网站时会自动创建 HttpSession，每个用户可以访问他自己的HttpSession。可以通过HttpServletRequest对象的getSession方 法获得HttpSession，通过HttpSession的setAttribute方法可以将一个值放在HttpSession中，通过调用 HttpSession对象的getAttribute方法，同时传入属性名就可以获取保存在HttpSession中的对象 Cookie和Session的的区别 Cookie 一般用来保存用户信息，登陆时将token存入cookie中，下次不用重新登陆。 Session 的主要作用就是通过服务端记录用户的状态，购物车场景]]></content>
  </entry>
  <entry>
    <title><![CDATA[第一篇博客]]></title>
    <url>%2F2018%2F11%2F30%2F%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2.html</url>
    <content type="text"><![CDATA[使用Guava retryer优雅的实现接口重调机制API 接口调用异常, 网络异常在我们日常开发中经常会遇到，这种情况下我们需要先重试几次调用才能将其标识为错误并在确认错误之后发送异常提醒。guava-retry可以灵活的实现这一功能。Guava retryer在支持重试次数和重试频度控制基础上，能够兼容支持多个异常或者自定义实体对象的重试源定义，让重试功能有更多的灵活性。Guava Retryer也是线程安全的，入口调用逻辑采用的是Java.util.concurrent.Callable的call方法。 使用Guava retryer 很简单，我们只要做以下几步： Step1、引入Guava-retry ``` java /** * 首页 * * @param name 名字 * @return java.lang.String */ @ApiOperation(value=&quot;获取图书列表&quot;, notes=&quot;获取图书列表&quot;) @ApiImplicitParam(name = &quot;name&quot;, value = &quot;图书详细实体&quot;, required = true, dataType = &quot;String&quot;) @GetMapping(&quot;home&quot;) public String home(@RequestParam(value = &quot;name&quot;, defaultValue = &quot;Jason Pan&quot;) String name) { return &quot;Hi &quot; + name + &quot; , I&#39;m from port:&quot; + port123; } ```]]></content>
      <categories>
        <category>develop</category>
        <category>test</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>os</tag>
        <tag>java</tag>
        <tag>python</tag>
      </tags>
  </entry>
</search>
